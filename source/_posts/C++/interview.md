##### 不能声明为虚函数的有？

虚函数是用于实现运行期的动态绑定。

* 构造函数（还未构造完成，没有虚函数表，当然无法调用）
* 内联函数 （编译期由编译器在调用出展开，但运行期才知道对象实际类型）
* 静态成员函数（静态成员函数没有继承体系，属于类）
* 模板函数（编译器处理类定义的时候要确定虚函数表的大小）

 

##### 为何static成员函数不能为`const`函数？

1. `const`用于表示不修改成员变量，但`static`并没有对象一说。
2. 当声明一个非静态成员函数为`const`时，对this指针会有影响。
   * 对于一个Test类中的`const`修饰的成员函数，this指针相当于`Test const *`, 而对于非`const`成员函数，this指针相当于Test *.
   *  而static成员函数没有`this`指针，所以使用`const`来修饰`static`成员函数没有任何意义。
   * volatile的道理也是如此。



##### `new`和`malloc`的区别

构造对象首先分配内存，其次调用类的构造函数。

new做两件事：分配内存和调用类的构造函数，delete是：调用类的析构函数和释放内存。

而malloc和free只是分配和释放内存，没构造和析构。但可利用一个块分配好的内存进行多次构造对象，new的这种用法称为**placement new**。

1. new/delete是关键字，效率高于malloc和free。需要配套使用。
1. 重载的`operator new()`/`operator delete()`仅仅负责分配/释放内存。
1. `new`无需显式指定大小，而malloc需要。 
1. new要么成功要么异常，而malloc失败返回NULL。



##### 指针和引用的区别

引用底层由指针实现。

* 引用需要初始化，而指针不需要。因此，引用无需校验对象是否存在，而指针要检验`nullptr`。
* 引用相当于别名，不占内存。而指针需要占用一个内存单元。

当然还有一些语法上的区别，如指针有多级而只有一级引用，指针可以再指向新的对象，而引用不行。
