

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/girl.png">
  <link rel="icon" href="/img/girl.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Epoch">
  <meta name="keywords" content="Epoch Blog">
  
    <meta name="description" content="SlubSlab是基于Buddy的分配器，也就是首先向Buddy分配对应的大内存，对这块内存进行管理，从而避免内部碎片。 具体的，Slab向Buddy申请特地大小的内存，这块内存的大小要求能被结构体大小整除，即正好能放下完整的对象，不会存在内部碎片。 Slab策略看起来像池的思想，但由于对象类型很多，不可能每个都分配一个池，Slab可以看成一个通用的拟内存池机制。 一个Slab包含一个或多个连续的">
<meta property="og:type" content="article">
<meta property="og:title" content="Slub">
<meta property="og:url" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/index.html">
<meta property="og:site_name" content="Epoch">
<meta property="og:description" content="SlubSlab是基于Buddy的分配器，也就是首先向Buddy分配对应的大内存，对这块内存进行管理，从而避免内部碎片。 具体的，Slab向Buddy申请特地大小的内存，这块内存的大小要求能被结构体大小整除，即正好能放下完整的对象，不会存在内部碎片。 Slab策略看起来像池的思想，但由于对象类型很多，不可能每个都分配一个池，Slab可以看成一个通用的拟内存池机制。 一个Slab包含一个或多个连续的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/IMG_20230219_150319.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/image-20230219153640741.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/fb5c1519305301.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/10fb1519305301.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/09dd1519305302.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/82661519305303.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/f19c1519305304.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/9eb91519305304.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/602e1519305305.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/7afb1519305306.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/586e1519305307.png">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/59b21519305308.png">
<meta property="article:published_time" content="2023-12-18T11:03:14.605Z">
<meta property="article:modified_time" content="2023-12-18T11:03:14.605Z">
<meta property="article:author" content="Epoch">
<meta property="article:tag" content="Epoch Blog">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://messenger1th.github.io/2023/12/18/Linux/Slub/IMG_20230219_150319.png">
  
  
  
  <title>Slub - Epoch</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"messenger1th.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Epoch</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/messenger1th">
                <i class="iconfont icon-github-fill"></i>
                GitHub
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Slub"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-18 19:03" pubdate>
          2023年12月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          164 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Slub</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Slub"><a href="#Slub" class="headerlink" title="Slub"></a>Slub</h1><p>Slab是基于Buddy的分配器，也就是首先向Buddy分配对应的大内存，对这块内存进行管理，从而避免内部碎片。</p>
<p>具体的，Slab向Buddy申请特地大小的内存，这块内存的大小要求能被结构体大小整除，即正好能放下完整的对象，不会存在内部碎片。</p>
<p>Slab策略看起来像池的思想，但由于对象类型很多，不可能每个都分配一个池，Slab可以看成一个通用的拟内存池机制。</p>
<p>一个Slab包含一个或多个连续的物理页面，然后将这些页面均分成固定的大小的各等份，每一等份就是一个对象，各对象通过链表串起来。有关slab 的信息封装在 <code>page</code> 中，对应的字段如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: include/linux/mm_types.h */</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span>
    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* slab, slob and slub */</span>
            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>
                <span class="hljs-comment">/* slab 列表，slab 可能在 partial */</span>
                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span>
                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* Partial pages */</span>
                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">next</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span>
                    <span class="hljs-type">int</span> pages; <span class="hljs-comment">/* Nr of pages left */</span>
                    <span class="hljs-type">int</span> pobjects; <span class="hljs-comment">/* Approximate count */</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pages;
                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pobjects;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
                &#125;;
            &#125;;
            <span class="hljs-comment">/* 使用该页作为 slab 的 kmem_cache, 通过文件 slub.c 中的函数 allocate_slab() 设置 */</span>
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span> <span class="hljs-comment">/* not slob */</span>
            <span class="hljs-comment">/* 当页面用于 slab 缓存时，slab 的首页对应的 page 的该字段会指向整个 slab 的空闲对象列表。</span>
<span class="hljs-comment">             * 但当 slab 当前正在被 kmem_cache_cpu 使用时，page 的该字段会设置为 NULL, 而 kmem_cache_cpu 中的 freelist 字段会指向 slab 的空闲对象列表 */</span>
            <span class="hljs-type">void</span> *freelist; <span class="hljs-comment">/* first free object */</span>
            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>
                <span class="hljs-type">void</span> *s_mem; <span class="hljs-comment">/* slab: first object */</span>
                <span class="hljs-comment">/* 因为 counters 与下面包含 inuse, objects, frozen 字段的结构体是 union 关系，所以很多时候需要新建 page 然后对后面三个字段赋值时，直接将 counters 的值付过去就 OK 了 */</span>
                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters; <span class="hljs-comment">/* SLUB */</span>
                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* SLUB */</span>
                    <span class="hljs-comment">/* 记录被使用的对象，但是初始值与 objects 相同 */</span>
                    <span class="hljs-type">unsigned</span> inuse : <span class="hljs-number">16</span>;
                    <span class="hljs-comment">/* 记录 slab 中包含 object 的总数，即为 kmem_cache 中 kmem_cache_order_objects 中低 15 位表示的值。该值在 slub.c 中的函数 allocate_slab 中设置 */</span>
                    <span class="hljs-type">unsigned</span> objects : <span class="hljs-number">15</span>;
                    <span class="hljs-comment">/* 标记该 slab 是否被某个 cpu “锁定”，如果处于 frozen 状态，那么只有对应的CPU 能够从该slab中分配对象，其他CPU 只能往该页面释放对象。初始值设置为 1 */</span>
                    <span class="hljs-type">unsigned</span> frozen : <span class="hljs-number">1</span>;
                &#125;;
            &#125;;
        &#125;;
&#125; _struct_page_alignment;</code></pre></div>

<p>如果页面被分配用于 slab, 那么这些字段就会被设置。其中 <strong><code>kmem_cache</code></strong> 与注释中提到的 <strong><code>kmem_cache_cpu</code></strong> 等是重点关注的结构。</p>
<h2 id="Slub接口及使用"><a href="#Slub接口及使用" class="headerlink" title="Slub接口及使用"></a>Slub接口及使用</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> kmem_cache *<span class="hljs-title function_">kmem_cache_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-comment">//kmem_cache的名称</span></span>
<span class="hljs-params">        <span class="hljs-type">size_t</span> size, <span class="hljs-comment">//slab管理对象的大小</span></span>
<span class="hljs-params">        <span class="hljs-type">size_t</span> align, <span class="hljs-comment">//slab分配器分配内存的对齐字节数(以align字节对齐)</span></span>
<span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-comment">//分配内存掩码，实际会调用到buddy处执行。</span></span>
<span class="hljs-params">        <span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *))</span>; <span class="hljs-comment">//分配对象的构造回调函数</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">kmem_cache_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *)</span>; <span class="hljs-comment">//销毁该cache</span>
<span class="hljs-type">void</span> *<span class="hljs-title function_">kmem_cache_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-type">int</span> flags)</span>; <span class="hljs-comment">//从该cache分配一块对象</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">kmem_cache_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-type">void</span> *objp)</span>; <span class="hljs-comment">//从该cache回收指定对象</span></code></pre></div>

<p><strong>使用步骤如下</strong></p>
<ol>
<li>mem_cache_create创建一个kmem_cache数据结构。</li>
<li>使用kmem_cache_alloc接口分配内存给buf</li>
<li>使用buf</li>
<li>kmem_cache_free接口释放buf。</li>
<li>release第一步创建的kmem_cache数据结构。</li>
</ol>
<p>代码如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> *　This is a demo for how to use kmem_cache_create</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">slab_demo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
&#123;
    <span class="hljs-comment">/*1. create kmem_cache. */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">kmem_cache_16</span> =</span> kmem_cache_create(<span class="hljs-string">&quot;kmem_cache_16&quot;</span>, <span class="hljs-number">16</span>,
            <span class="hljs-number">8</span>, ARCH_KMALLOC_FLAGS,
            <span class="hljs-literal">NULL</span>);
 
    <span class="hljs-comment">/*2. now you can alloc memory, the buf points to 16 bytes of memory*/</span>
    <span class="hljs-type">char</span> *buf = kmeme_cache_alloc(kmem_cache_16, GFP_KERNEL);
 	<span class="hljs-comment">/*3. use buf...*/</span>
    
    <span class="hljs-comment">/*4. and 5. don&#x27;t forget to release the memory after use */</span>
    kmem_cache_free(kmem_cache_16, buf);
    kmem_cache_destroy(kmem_cache_16);
&#125;</code></pre></div>

<h2 id="创建slab"><a href="#创建slab" class="headerlink" title="创建slab"></a>创建slab</h2><p>内核创建一个slab的逻辑也很直观：首先向Buddy System申请一定数量的连续页面，然后初始化对象并构建好对象列表。代码如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: mm/slub.c */</span>

<span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">allocate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span> &#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span>
    <span class="hljs-comment">/* 结构 kmem_cache_order_objects 中记录着一个 slab 应该申请的页面数量与总的对象数量，两个量封装在一个字段 unsigned int x 中，其中低16位表示对象总数，高位表示连续页面的阶，即需要分配2^(oo.x &gt;&gt; 16)个连续页面 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span> =</span> s-&gt;oo;
    <span class="hljs-comment">/* 传给Buddy System的各类Flag, 这里我们删掉了对该参数的初始化逻辑 */</span>
    <span class="hljs-type">gfp_t</span> alloc_gfp;
    <span class="hljs-comment">/* 初始化对象列表时使用的指针变量 */</span>
    <span class="hljs-type">void</span> *start, *p, *next;
    <span class="hljs-type">int</span> idx;
    <span class="hljs-type">bool</span> shuffle;

    <span class="hljs-comment">/* 分配连续 2^(oo.x&gt;&gt;OO_SHIFT) 个连续页面，其中 OO_SHIFT 为 16  */</span>
    page = alloc_slab_page(s, alloc_gfp, node, oo);
    <span class="hljs-keyword">if</span> (unlikely(!page)) &#123;
        <span class="hljs-comment">/* 如果 buddy system 没有足够的连续物理页，则减少 oo 的数值再尝试一次 */</span>
        oo = s-&gt;min;
        alloc_gfp = flags;
        page = alloc_slab_page(s, alloc_gfp, node, oo);
        <span class="hljs-comment">/* s-&gt;min 是实例化一个 slab 所需要的最小的内存页数量，如果依旧无法满足的话就直接退出了 */</span>
        <span class="hljs-keyword">if</span> (unlikely(!page))
            <span class="hljs-keyword">goto</span> out;
        stat(s, ORDER_FALLBACK);
    &#125;

    <span class="hljs-comment">/* oo.x 的低 15 位表示该 slab 中可以存放的 object 总数 */</span>
    <span class="hljs-comment">/* 函数oo_objects 就是取出 oo.x 的低16位的数字，即 oo.x&amp;(1&lt;&lt;16 -1) 的值*/</span>
    page-&gt;objects = oo_objects(oo);

    <span class="hljs-comment">/* 将 kmem_cache 记录到第一个内存页中，kmem_cache 在下一节介绍 */</span>
    page-&gt;slab_cache = s;
    <span class="hljs-comment">/* 设置 page 的标记位，标记该页面用于 slab */</span>
    __SetPageSlab(page);

    start = page_address(page);

    shuffle = shuffle_freelist(s, page);

    <span class="hljs-comment">/* if block 中构建对象列表 */</span>
    <span class="hljs-keyword">if</span> (!shuffle) &#123;
        <span class="hljs-comment">/* 初始化第一个对象，因为 for 循环中处理的都是下一个对象 */</span>
        start = fixup_red_left(s, start);
        <span class="hljs-comment">/* 如果为 slab 配置了对象的初始化函数，则会在函数 setup_object 调用，对每个对象进行初始化  */</span>
        start = setup_object(s, page, start);
        <span class="hljs-comment">/* slab 中空闲对象列表的地址为第一个对象 */</span>
        page-&gt;freelist = start;
        <span class="hljs-comment">/* 初始化 slab 中的空闲对象列表 */</span>
        <span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>, p = start; idx &lt; page-&gt;objects - <span class="hljs-number">1</span>; idx++) &#123;
            <span class="hljs-comment">/* s-&gt;size 表示每个对象的大小，这里计算出下一个对象的地址 */</span>
            next = p + s-&gt;size;
            <span class="hljs-comment">/* 初始化下一个对象 */</span>
            next = setup_object(s, page, next);
            <span class="hljs-comment">/* 建立空闲对象列表的单链表，其中 p 为当前对象，next 为下一个对象，将 next 的地址写入 p+s.offset 位置处 */</span>
            set_freepointer(s, p, next);
            p = next;
        &#125;
        <span class="hljs-comment">/* 链表最后一个元素的next属性指向 NULL */</span>
        set_freepointer(s, p, <span class="hljs-literal">NULL</span>);
    &#125;

    page-&gt;inuse = page-&gt;objects;
    page-&gt;frozen = <span class="hljs-number">1</span>;

out:
    <span class="hljs-keyword">if</span> (!page)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">return</span> page;
&#125;</code></pre></div>

<h2 id="Slab管理空闲对象"><a href="#Slab管理空闲对象" class="headerlink" title="Slab管理空闲对象"></a>Slab管理空闲对象</h2><p>前文中我们提到过slab中的对象就是一个固定大小的连续内存块，通过对象列表的构建逻辑我们可以对此有更深刻的理解，内核并没有单独定义一个结构体来封装对象信息，在构建对象列表时，指向下一个空闲对象的指针也是直接存放在该对象的内存地址内部，因为对象还没有被分配出去时内存是不会被使用的，而被分配之后也不需要该指针了，这是一个比较精巧的设计。</p>
<p><img src="/2023/12/18/Linux/Slub/IMG_20230219_150319.png" srcset="/img/loading.gif" lazyload alt="IMG_20230219_150319"></p>
<p>页面的freelist 总是指向slab 中第一个空闲对象，也是 slab 分配与释放对象的入口点。</p>
<p>首先一个slab缓存池包含的页数是由oo决定的。oo拆分为两部分，低16位代表一个slab缓存池中object的数量，高16位代表包含的页数。使用kmem_cache_create()接口创建kmem_cache的时候需要指出obj的size和对齐align。也就是传入的参数。kmem_cache_create()主要是就是填充kmem_cache结构体成员。既然从伙伴系统得到(2^(oo &gt;&gt; 16)) pages大小内存，按照size大小进行平分。一般来说都不会整除，因此剩下的就是图中灰色所示。由于每一个object的大小至少8字节，当然可以用来存储下一个object的首地址。就像图中所示的，形成单链表。图中所示下个obj地址存放的位置位于每个obj首地址处，在内核中称作指针内置式。同时，下个obj地址存放的位置和obj首地址之间的偏移存储在kmem_cache的offset成员。两外一种方式是指针外置式，即下个obj的首地址存储的位置位于obj尾部，也就是在obj尾部再分配sizeof(void *)字节大小的内存。对于外置式则offset就等于kmem_cache的inuse成员。</p>
<h2 id="整体组织"><a href="#整体组织" class="headerlink" title="整体组织"></a>整体组织</h2><p>我们把每次向Buddy申请的那块内存，称为slab。每个slab的第一个页面会存储本slab的管理信息。页面内的对象以链表组织。页面与页面之间以单链表组织。</p>
<p>不同slab大小由不同的<code>kmem_cache</code>管理。每种<code>kmem_cache</code>的名称、大小等属性有所不同，但管理方式一致。</p>
<p>CPU一般是多核心的，为了减少锁的开小，为每一个CPU核心都创建一个缓存。整体组织如下</p>
<p><img src="/2023/12/18/Linux/Slub/image-20230219153640741.png" srcset="/img/loading.gif" lazyload alt="image-20230219153640741"></p>
<p>所有的、不同大小的 <code>kmem_cache</code> 保留在全局变量 <code>kmalloc_caches</code> 中。由slub的接口可知，具体请求哪一个<code>kmem_cache</code>内的对象，是由内核开发者函数传参决定的。</p>
<h3 id="per-cpu-freelist"><a href="#per-cpu-freelist" class="headerlink" title="per cpu freelist"></a>per cpu freelist</h3><p>针对每一个cpu都会分配一个<code>struct kmem_cache_cpu</code>的结构体。可以称作是本地缓存池。当内存申请的时候，优先从本地cpu缓存池申请。在分配初期，本地缓存池为空，自然要从伙伴系统分配一定页数的内存。内核会为每一个物理页帧创建一个struct page的结构体。kmem_cacche_cpu中page就会指向正在使用的slab的页帧。freelist成员指向第一个可用内存obj首地址。处于正在使用的slab的struct page结构体中的freelist会置成NULL，因为没有其他地方使用。struct page结构体中inuse代表已经使用的obj数量。full slab就像无人看管的孩子，没有任何链表来管理。释放完全由内核开发者手动。</p>
<h3 id="per-cpu-partial"><a href="#per-cpu-partial" class="headerlink" title="per cpu partial"></a>per cpu partial</h3><p>当full slab释放obj的时候，首先就会将slab挂入per cpu partial链表管理。通过struct page中next成员形成单链表。per cpu partial链表指向的第一个page中会存放一些特殊的数据。例如：pobjects存储着per cpu partial链表中所有slab可供分配obj的总数，如图所示。当然还有一个图中没有体现的pages成员存储per cpu partial链表中所有slab缓存池的个数。pobjects到底有什么用呢？我们从full slab中释放一个obj就添加到per cpu partial链表，总不能无限制的添加吧！因此，每次添加的时候都会判断当前的pobjects是否大于kmem_cache的cpu_partial成员，如果大于，那么就会将此时per cpu partial链表中所有的slab移送到kmem_cache_node的partial链表，然后再将刚刚释放obj的slab插入到per cpu partial链表。如果不大于，则更新pobjects和pages成员，并将slab插入到per cpu partial链表。</p>
<h3 id="per-node-partial"><a href="#per-node-partial" class="headerlink" title="per node partial"></a>per node partial</h3><p>per node partia链表类似per cpu partial，区别是node中的slab是所有cpu共享的，而per cpu是每个cpu独占的。假如现在的slab布局如上图所示。假如现在如红色箭头指向的obj将会释放，那么就是一个empty slab，此时判断kmem_cache_node的nr_partial是否大于kmem_cache的min_partial，如果大于则会释放该slab的内存。 </p>
<h2 id="Slub内存分配流程"><a href="#Slub内存分配流程" class="headerlink" title="Slub内存分配流程"></a>Slub内存分配流程</h2><p>由创建cache的流程，不难发现cache会记录对象大小和构造函数。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> kmem_cache *<span class="hljs-title function_">kmem_cache_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-comment">//kmem_cache的名称</span></span>
<span class="hljs-params">        <span class="hljs-type">size_t</span> size, <span class="hljs-comment">//slab管理对象的大小</span></span>
<span class="hljs-params">        <span class="hljs-type">size_t</span> align, <span class="hljs-comment">//slab分配器分配内存的对齐字节数(以align字节对齐)</span></span>
<span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-comment">//分配内存掩码，实际会调用到buddy处执行。</span></span>
<span class="hljs-params">        <span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *))</span>; <span class="hljs-comment">//分配对象的构造回调函数</span></code></pre></div>

<p>创建时，仅仅需要传递<code>kmem_cache</code>和标志信息<code>flags</code>。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmem_cache_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-type">int</span> flags)</span>; <span class="hljs-comment">//从该cache分配一块对象</span></code></pre></div>

<p>深入原理，分配顺序是</p>
<ul>
<li>cpu的<code>freelist</code></li>
<li>cpu的<code>partial</code></li>
<li>各核心共享的<code>node</code></li>
</ul>
<p>首先从cpu 本地缓存池分配，如果freelist不存在，就会转向per cpu partial分配，如果per cpu partial也没有可用对象，继续查看per node partial，如果很不幸也不没有可用对象的话，就只能从伙伴系统分配一个slab了，并挂入per cpu freelist。</p>
<p>流程图如下</p>
<p><img src="/2023/12/18/Linux/Slub/fb5c1519305301.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>我们详细看一下这几种情况。</p>
<ol>
<li><p>kmem_cache刚刚建立，还没有任何对象可供分配，此时只能从伙伴系统分配一个slab，如下图所示。</p>
<p><img src="/2023/12/18/Linux/Slub/10fb1519305301.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
</li>
<li><p>如果正在使用的slab有free obj，那么就直接分配即可，这种是最简单快捷的。如下图所示。</p>
</li>
</ol>
<p>   <img src="/2023/12/18/Linux/Slub/09dd1519305302.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<ol start="3">
<li><p>随着正在使用的slab中obj的一个个分配出去，最终会无obj可分配，此时per cpu partial链表中有可用slab用于分配，那么就会从per cpu partial链表中取下一个slab用于分配obj。如下图所示。</p>
<p><img src="/2023/12/18/Linux/Slub/82661519305303.png" srcset="/img/loading.gif" lazyload alt="5.png"></p>
</li>
<li><p>随着正在使用的slab中obj的一个个分配出去，最终会无obj可分配，此时per cpu partial链表也为空，此时发现per node partial链表中有可用slab用于分配，那么就会从per node partial链表中取下一个slab用于分配obj。如下图所示。</p>
</li>
</ol>
<p>   <img src="/2023/12/18/Linux/Slub/f19c1519305304.png" srcset="/img/loading.gif" lazyload alt="6.png"></p>
<ol start="5">
<li>走到这一步，说明<code>node_partial</code>也没有可用对象，就只能从伙伴系统分配一个slab了。</li>
</ol>
<h2 id="Slub内存释放流程"><a href="#Slub内存释放流程" class="headerlink" title="Slub内存释放流程"></a>Slub内存释放流程</h2><p>通过<code>void kmem_cache_free()</code>回收指定对象，具体签名如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kmem_cache_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-type">void</span> *objp)</span>; <span class="hljs-comment">//从该cache回收指定对象</span></code></pre></div>

<p>释放流程图如下</p>
<p><img src="/2023/12/18/Linux/Slub/9eb91519305304.png" srcset="/img/loading.gif" lazyload alt="7.png"></p>
<p>如果释放的obj就是属于正在使用cpu上的slab，那么直接释放即可，非常简单；如果不是的话，首先判断所属slub是不是full状态，因为full slab是没妈的孩子，释放之后就变成partial empty，急需要找个链表领养啊！这个妈就是per cpu partial链表。如果per cpu partial链表管理的所有slab的free object数量超过kmem_cache的cpu_partial成员的话，就需要将per cpu partial链表管理的所有slab移动到per node partial链表管理；如果不是full slab的话，继续判断释放当前obj后的slab是否是empty slab，如果是empty slab，那么在满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的情况下，则会释放该slab的内存。其他情况就直接释放即可。</p>
<p><strong>即，<code>min_cpu_partial</code>保证CPU有一定数量的缓存对象，而<code>min_partial</code>保证node有一定数量的缓存对象。</strong></p>
<p>具体情况分析如下</p>
<ol>
<li><p>释放该对象后，整个slab都空闲，则回收整个slab；释放完该对象，所属slab不全空闲，则移动该对象到空闲链表，如下图。</p>
<p>假设下图左边的情况下释放obj，如果满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的话，释放情况如下图所示。</p>
<p><img src="/2023/12/18/Linux/Slub/602e1519305305.png" srcset="/img/loading.gif" lazyload alt="8.png"></p>
</li>
<li><p>假设下图左边的情况下释放obj，如果不满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的话，释放情况如下图所示。即min_partial保证该<code>kmem_cache</code>有最低数量的slab。</p>
<p><img src="/2023/12/18/Linux/Slub/7afb1519305306.png" srcset="/img/loading.gif" lazyload alt="9.png"></p>
</li>
<li><p>假设下图从full slab释放obj的话，如果满足per cpu partial管理的所有slab的free object数量大于kmem_cache的cpu_partial成员的话的话，将per cpu partial链表管理的所有slab移动到per node partial链表管理，释放情况如下图所示。</p>
<p><img src="/2023/12/18/Linux/Slub/586e1519305307.png" srcset="/img/loading.gif" lazyload alt="10.png"></p>
</li>
<li><p>假设下图从full slab释放obj的话，如果不满足per cpu partial管理的所有slab的free object数量大于kmem_cache的cpu_partial成员的话的话，释放情况如下图所示。</p>
<p><img src="/2023/12/18/Linux/Slub/59b21519305308.png" srcset="/img/loading.gif" lazyload alt="11.png"></p>
</li>
</ol>
<h2 id="kmalloc和vmalloc"><a href="#kmalloc和vmalloc" class="headerlink" title="kmalloc和vmalloc"></a>kmalloc和vmalloc</h2><p>看起来Slab只能分配固定大小的的内存，实际上，<strong>Linux的Slab实现了kmalloc和vmalloc，可以提供不同大小的可分配内存。</strong></p>
<p><strong>kmalloc</strong>、<strong>vmalloc</strong>对于常用的大小，创建了对应大小的的高速缓存组，部分如下。分配时找到第一个大于等于请求值的那个缓存组分配即可。</p>
<h3 id="kmalloc和vmalloc接口"><a href="#kmalloc和vmalloc接口" class="headerlink" title="kmalloc和vmalloc接口"></a>kmalloc和vmalloc接口</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span>; 
<span class="hljs-type">void</span> * <span class="hljs-title function_">vmalloc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* ptr)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">vfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr)</span>;</code></pre></div>

<p>kmallo和vmalloc具体实现原理就在是创建多个不同大小的<code>kmem_cache</code>，可以通过<code>cat /proc/slabinfo</code>查看所有的<code>kmem_cache</code>，其中含kmalloc就是用于分配不固定大小的内存。</p>
<div class="code-wrapper"><pre><code class="hljs shell">root:/ # cat /proc/slabinfo | grep &quot;kmalloc&quot;
kmalloc-8k           407    416   8192    4    8 : tunables    0    0    0 : slabdata    104    104      0
kmalloc-4k          3189   3256   4096    8    8 : tunables    0    0    0 : slabdata    407    407      0
kmalloc-2k          2647   2800   2048   16    8 : tunables    0    0    0 : slabdata    175    175      0
kmalloc-1k          4177   4256   1024   32    8 : tunables    0    0    0 : slabdata    133    133      0
kmalloc-512        22044  55360    512   32    4 : tunables    0    0    0 : slabdata   1730   1730      0
kmalloc-256        20964  23168    256   32    2 : tunables    0    0    0 : slabdata    724    724      0
kmalloc-192        20440  22638    192   21    1 : tunables    0    0    0 : slabdata   1078   1078      0
kmalloc-128         3427   4192    128   32    1 : tunables    0    0    0 : slabdata    131    131      0
kmalloc-96          5628   5628     96   42    1 : tunables    0    0    0 : slabdata    134    134      0
kmalloc-64         26512  27584     64   64    1 : tunables    0    0    0 : slabdata    431    431      0
kmalloc-32         60345  61568     32  128    1 : tunables    0    0    0 : slabdata    481    481      0
kmalloc-16         24109  27136     16  256    1 : tunables    0    0    0 : slabdata    106    106      0
kmalloc-8          12800  12800      8  512    1 : tunables    0    0    0 : slabdata     25     25      0</code></pre></div>

<p>假如通过kmalloc(17, GFP_KERNEL)申请内存，系统会从名称“kmalloc-32”管理的slab缓存池中分配一个对象。即使浪费了15Byte。</p>
<p>通过slab接口分配的最大内存是8192 bytes。那么通过kmalloc接口申请的内存大于8192 bytes该怎么办呢？</p>
<p>其实kmalloc会判断申请的内存是否大于8192 bytes，如果大于的话就会通过伙伴系统的<code>alloc_pages</code>接口申请内存。</p>
<h3 id="kmalloc和vmalloc区别"><a href="#kmalloc和vmalloc区别" class="headerlink" title="kmalloc和vmalloc区别"></a>kmalloc和vmalloc区别</h3><p>kmalloc分配的内存是物理连续的，而vmalloc是不一定是物理连续的。当然它们都是逻辑连续的。</p>
<p>vmalloc通过分配非连续的物理内存块，再修正页表，实现逻辑连续。由于需要建立页表项，同时一个一个地进行映射，导致分配慢、TLB抖动，都会影响效率。因此，内核在不得已才使用，如分配大块内存的情况下，比如加载模块。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/426.html">图解slub</a></li>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/247.html">slub分配器</a></li>
<li><a target="_blank" rel="noopener" href="https://s3.shizhz.me/linux-mm/3.2-wu-li-nei-cun/3.2.5-slab-slub-slob#org9a182bb">3.2.5 SLAB&#x2F;SLUB&#x2F;SLOB</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Slub</div>
      <div>https://messenger1th.github.io/2023/12/18/Linux/Slub/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Epoch</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/18/Linux/Virtual%20Memory/" title="Virtual Memory">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Virtual Memory</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/18/Linux/Physical%20Memory/" title="Physical Memory">
                        <span class="hidden-mobile">Physical Memory</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-left: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Linux"
        id="heading-edc9f0a5a5d57797bf68e37364743831" role="tab" data-toggle="collapse" href="#collapse-edc9f0a5a5d57797bf68e37364743831"
        aria-expanded="true"
      >
        Linux
        <span class="list-group-count">(6)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-edc9f0a5a5d57797bf68e37364743831"
           role="tabpanel" aria-labelledby="heading-edc9f0a5a5d57797bf68e37364743831">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/12/18/Linux/Ext%20File%20System/" title="Ext File System"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Ext File System</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Physical%20Memory/" title="Physical Memory"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Physical Memory</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Process/" title="Process"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Process</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Slub/" title="Slub"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">Slub</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Virtual%20Memory/" title="Virtual Memory"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Virtual Memory</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络编程</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
