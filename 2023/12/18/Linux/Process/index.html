

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/girl.png">
  <link rel="icon" href="/img/girl.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Epoch">
  <meta name="keywords" content="Epoch Blog">
  
    <meta name="description" content="Linux进程进程状态进程创建进程创建可以通过3个函数  fork：拷贝当前进程，创建出一个子进程。 vfork：类似fork，但不复制父进程的页表项。但由于copy on write技术的出现，这个函数的相对于fork的优势越来越小。 clone：最基本的函数，根据各种标志位指定父子进程需要共享的资源，比如虚拟内存。共享虚拟内存的话就是常说的线程。  实际上，fork和vfork的实现都是调用的">
<meta property="og:type" content="article">
<meta property="og:title" content="Process">
<meta property="og:url" content="https://messenger1th.github.io/2023/12/18/Linux/Process/index.html">
<meta property="og:site_name" content="Epoch">
<meta property="og:description" content="Linux进程进程状态进程创建进程创建可以通过3个函数  fork：拷贝当前进程，创建出一个子进程。 vfork：类似fork，但不复制父进程的页表项。但由于copy on write技术的出现，这个函数的相对于fork的优势越来越小。 clone：最基本的函数，根据各种标志位指定父子进程需要共享的资源，比如虚拟内存。共享虚拟内存的话就是常说的线程。  实际上，fork和vfork的实现都是调用的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Process/CamScanner%2002-08-2023%2015.22.jpg">
<meta property="og:image" content="https://messenger1th.github.io/2023/12/18/Linux/Process/CamScanner%2002-08-2023%2015.22_2.jpg">
<meta property="article:published_time" content="2023-12-18T11:03:14.603Z">
<meta property="article:modified_time" content="2023-12-18T11:03:14.603Z">
<meta property="article:author" content="Epoch">
<meta property="article:tag" content="Epoch Blog">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://messenger1th.github.io/2023/12/18/Linux/Process/CamScanner%2002-08-2023%2015.22.jpg">
  
  
  
  <title>Process - Epoch</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"messenger1th.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Epoch</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/messenger1th">
                <i class="iconfont icon-github-fill"></i>
                GitHub
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Process"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-18 19:03" pubdate>
          2023年12月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          336 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Process</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h1><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程创建可以通过3个函数</p>
<ul>
<li>fork：拷贝当前进程，创建出一个子进程。</li>
<li>vfork：类似fork，但不复制父进程的页表项。但由于copy on write技术的出现，这个函数的相对于fork的优势越来越小。</li>
<li>clone：最基本的函数，根据各种标志位指定父子进程需要共享的资源，比如虚拟内存。<strong>共享虚拟内存的话就是常说的线程。</strong></li>
</ul>
<p>实际上，fork和vfork的实现都是调用的clone，并指定特定的标志指定父子进程需要共享的资源。</p>
<p>clone函数的核心是do_fork函数，该函数执行流程如下。</p>
<p><img src="/2023/12/18/Linux/Process/CamScanner%2002-08-2023%2015.22.jpg" srcset="/img/loading.gif" lazyload alt="CamScanner 02-08-2023 15.22"></p>
<p>其中，<code>copy_process</code>函数为进程创建一个内核栈、thread_info结构和task_struct结构，根据传递给clone的参数，拷贝对应的资源。<img src="/2023/12/18/Linux/Process/CamScanner%2002-08-2023%2015.22_2.jpg" srcset="/img/loading.gif" lazyload alt="CamScanner 02-08-2023 15.22_2" style="zoom: 33%;"></p>
<h4 id="创建新程序"><a href="#创建新程序" class="headerlink" title="创建新程序"></a>创建新程序</h4><p>问题来了，这三个函数只能拷贝父进程，运行的代码都是一样的，那怎么创建别的程序呢？</p>
<p><code>execve()</code>函数可以读取其他可执行文件，并加载到内存运行。此外，还有<code>execve()</code>的封装函数<code>execlp()</code>, <code>execle()</code>,<code>execv()</code>,<code>execvp()</code>，<code>exec()</code>。我们称为<code>exec</code>函数族。</p>
<p>那么创建新进程的就只需要<strong>调用<code>fork</code>&#x2F;<code>vfork</code>&#x2F;<code>clone</code>之后再调用<code>exec</code>函数</strong>即可。</p>
<p>Shell上调用其他命令就是这样实现的。</p>
<ul>
<li>首先使用fork创建出一个子进程，然后子进程调用<code>exec</code>执行其他进程。</li>
<li>如果有重定向号<code>&gt;</code>则在<code>exec</code>前关闭标准输出，打开新文件的描述符。</li>
</ul>
<h4 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy On Write"></a>Copy On Write</h4><p>Copy On Write顾名思义仅在写的时候才会复制出一个副本，也是属于懒加载的技术。</p>
<p>fork之后再exec的频率是很高的，复制的页表项相当于白白复制了，所以之前vfork就比fork要高效。</p>
<p>但出现了copy on write技术后，页表项仅仅在需要修改时才会复制，vfork就和fork一样了，基本上很少用了。</p>
<h4 id="Linux的线程"><a href="#Linux的线程" class="headerlink" title="Linux的线程"></a>Linux的线程</h4><p><strong>Linux下的进程和线程没有本质区别，都是由<code>task_struct</code>描述，由<code>clone</code>产生，本质只是是否共享内存。</strong>通过下面这句即可创建线程。</p>
<div class="code-wrapper"><pre><code class="hljs c">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="hljs-number">0</span>)</code></pre></div>



<h3 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h3><p>根据创建进程的过程不难发现，新进程都会有一个父进程。子进程需要结束时，首先做一些能做的操作，但自己总不能回收自己吧，就留下一些资源等待父进程调用wait回收。</p>
<p>Linux的第一个进程就是<code>init</code>进程，其他进程都是其后代，在一定情况下负责后代的回收。</p>
<p>一般来说，进程结束发生在调用<code>exit()</code>时候，既可能是程序手动调用，也可能是隐形式地被添加这个调用。（C语言编译器在<code>main()</code>的返回点后面放置调用<code>exit()</code>的代码）。也能是接受到无法处理且无法忽略的信号，被动终止。</p>
<p>不管怎么终结，都会调用<code>do_exit()</code>。之后，它占有的内存就只有内核栈，<code>thread_info</code>和<code>task_struct</code>了。</p>
<p>然后父进程调用<code>wait()</code>，就完成了子进程的回收。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>子进程终止，调用<code>do_exit()</code>.</li>
<li>父进程调用wait()，挂起自己，并等待自己的一个子进程的状态改变。</li>
</ul>
<h4 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h4><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>孤儿（orphan）进程是指父进程先退出但自己还未退出的子进程</p>
<p>如果父进程先退出，未<code>wait</code>子进程，子进程<code>do_exit()</code>会查找新的父进程。如果现场组内没有其他进程，则该回收任务交由<code>init</code>进程执行，其<code>pid</code>为1。<code>init</code>进程例行调用<code>wait()</code>检查子进程。</p>
<h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>僵尸（zombie）进程是已经退出但未经过<code>wait</code>的子进程。</p>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息。</p>
<p>这种机制就是: 在<code>do_exit</code>释放大部分资源后，仍然为其保留一定的信息(内核栈，<code>thread_info</code>和<code>task_struct</code>)。直到父进程通过wait &#x2F; waitpid来取时才释放。 但这样就导致了问题，<strong>如果进程不调用wait &#x2F; waitpid的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p>
<p>可以通过以下方式解决</p>
<ul>
<li>kill父进程，使子进程成为孤儿进程。</li>
<li>父进程重写信号处理函数，接收到信号就wait子进程。</li>
<li>fork两次，中间的进程直接退出。孙子进程成为孤儿进程。</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="调度实体"><a href="#调度实体" class="headerlink" title="调度实体"></a>调度实体</h4><p>为了简化调度器模型，内核单独抽象出了一个概念叫“调度实体”，用来封装调度对象， <code>struct task_struct</code> 与调度实体相关的字段包括：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: include/linux/sched.h */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span>
    <span class="hljs-comment">/* 调度实体，调度器的调度对象，该字段用于 CFS */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> <span class="hljs-title">se</span>;</span>
    <span class="hljs-comment">/* 该字段用于 RT 调度器 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_rt_entity</span> <span class="hljs-title">rt</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_group</span> *<span class="hljs-title">sched_task_group</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-comment">/* 该字段用于 DL 调度器 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_dl_entity</span> <span class="hljs-title">dl</span>;</span>
&#125;</code></pre></div>

<p>三个表示调度实体的字段 <code>se</code>, <code>rt</code>, <code>dl</code> 分别用于不同的调度策略。</p>
<h4 id="调度类"><a href="#调度类" class="headerlink" title="调度类"></a>调度类</h4><p>Linux 在 2.6 版本中引入了“调度类（Sched Class）”的概念，意在将调度逻辑模块化，内核通过 <code>struct sched_class</code> 抽象出了调度类的通用行为。这个结构体基本都是函数声明，这对于有 OO 编程经验的同学而言是很熟悉的： <code>struct sched_class</code> 实际上定义了一个接口（Interface），而各个调度类来负责具体的实现。</p>
<p>Linux 总共实现了5种调度类，按照优先级有高到底排序依次为：</p>
<ol>
<li><p><code>stop_sched_class</code>  Stop 是特殊的调度类，内核使用该调度类来停止 CPU. 该调度类用来强行停止CPU 上的其他任务，由于该调度类的优先级最高，因此一旦生效就将抢占任何当前正在运行的任务，并且在运行过程中自己不会被抢占。</p>
<p>该调度类只有在SMP架构的系统中存在，内核使用该调度类来完成负载均衡与CPU热插拔等工作。</p>
</li>
<li><p><code>dl_sched_class</code>  有些任务必须在指定时间窗口内完成。例如视频的编码与解码，CPU 必须以特定频率完成对应的数据处理；</p>
<p>这类任务是优先级最高的用户任务，CPU 应该首先满足。</p>
<p>Deadline 调度类用来调度这类任务，dl 便是单词 Deadline 的缩写，因此该调度类的优先级仅仅低于 Stop 调度类。</p>
</li>
<li><p><code>rt_sched_class</code>  实时任务（Real-time Task）对响应时间要求更高，例如编辑器软件，它可能由于等待用户输入长期处于睡眠之中，但一旦用户有输入动作，我们就期望编辑器能够立马响应，而不是等系统完成其它任务之后才开始反应，这一点对用户体验十分重要。</p>
<p>RT 调度类用来调度这类任务，该调度类的优先级低于 DL.</p>
</li>
<li><p><code>fair_sched_class</code>  Fair 调度类用来调度绝大多数用户任务，CFS 实现的就是这种调度类，其核心逻辑是根据任务的优先级公平地分配 CPU 时间。我们会在后续章节中详细讨论 CFS 的实现细节。</p>
</li>
<li><p><code>idle_sched_class</code>  与 Stop 类似，Idle 调度类也是仅供内核使用的特殊调度类，其优先级最低，只有在没有任何用户任务时才会用到。内核会为每个 CPU 绑定一个内核线程（kthread）来完成该任务，该线程会在队列无事可做的情况下启动该任务，并将 CPU 的功耗降到最低。</p>
</li>
</ol>
<p><strong>我们说调度类有优先级，具体怎么体现呢？</strong></p>
<p>每一个CPU的<code>rq</code>在选择下一个进程来运行，要调用<code>pick_next_task()</code>，该函数的定义如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> task_struct *
<span class="hljs-title function_">pick_next_task</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *prev, <span class="hljs-keyword">struct</span> rq_flags *rf)</span> &#123;
    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span> *<span class="hljs-keyword">class</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span>

    for_each_class(class) &#123;
        p = class-&gt;pick_next_task(rq);
        <span class="hljs-keyword">if</span> (p)
            <span class="hljs-keyword">return</span> p;
    &#125;

    <span class="hljs-comment">/* The idle class should always have a runnable task: */</span>
    BUG();
&#125;</code></pre></div>

<p>从上述代码不难发现，对调度类的遍历通过宏 <code>for_each_class</code> 完成。而该宏展开的之后，各调度类的顺序就是我们上述提到的优先级。每一个调度类都实现了<code>pick_next_task</code>，用于选择下一个调度的进程。先便利高优先级的调度类，如果有进程可调度，则直接返回。</p>
<p>在相同优先级调度类中可能管理多个进程的调度，因此调度类有会对应的调度策略。</p>
<h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><ol>
<li>Stop 调度类  Stop 调度类中只有一个任务可供执行，不需要定义任何调度策略。</li>
<li>DL （Deadline）调度类 DL 只实现了一种调度策略：<code>SCHED_DEADLINE</code>, 用来调度优先级最高的用户任务。</li>
<li>RT （Real-Time） RT 提供了两种调度策略：<code>SCHED_FIFO</code> 与 <code>SCHED_RR,</code>对于使用 <code>SCHED_FIFO</code> 的任务，其会一直运行到主动放弃CPU; 而对于 <code>SCHED_RR</code> 的任务，如果多个任务的优先级相同，则大家会按照一定的时间配额来交替运行，即使一个任务一直处于可运行状态，在使用完自己的时间切片之后也会被抢占，然后被放入队列的尾巴等待下次机会。</li>
<li>Fair CFS 实现了三种调度策略：<ul>
<li><code>SCHED_NORMAL</code>: 被用于绝大多数用户进程</li>
<li><code>SCHED_BATCH</code>: 适用于没有用户交互行为的后台进程，用户对该类进程的响应时间要求不高，但对吞吐量要求较高，因此调度器会在完成所有 <code>SCHED_NORMAL</code> 的任务之后让该类任务不受打扰地跑上一段时间，这样能够最大限度地利用缓存。</li>
<li><code>SCHED_IDLE</code>: 这类调度策略被用于系统中优先级最低的任务，只有在没有任何其他任务可运行时，调度器才会将运行该类任务。</li>
</ul>
</li>
<li>Idle 同 Stop 一样，Idle 调度类也没有实现调度策略，注意不要将这类调度类与 CFS 中的 <code>SCHED_IDLE</code> 混淆。</li>
</ol>
<p>每个进程在创建时都会指定一个调度策略，从而自动归结到某个调度类下。</p>
<p>调度策略的定义如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHED_NORMAL 0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHED_FIFO 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHED_RR 2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHED_BATCH 3</span>
<span class="hljs-comment">/* SCHED_ISO: reserved but not implemented yet */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHED_IDLE 5</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHED_DEADLINE 6</span></code></pre></div>

<p>可以通过 <code>/proc/&lt;pid&gt;/sched</code> 中的内容来查看进程的调度策略，例如</p>
<div class="code-wrapper"><pre><code class="hljs c">epoch@Ubuntu:~ $ cat /proc/<span class="hljs-number">130</span>/sched | grep policy
policy                                       :                    <span class="hljs-number">0</span></code></pre></div>



<h4 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h4><p>运行队列（run queue）rq 是系统可运行任务的容器，调度器的很多工作都是围绕着 rq 来进行的，调度类 <code>struct sched_class</code> 所申明的函数中，绝大多数函数都与 rq 相关。<strong>在系统中，每个 CPU 都有一个自己的 rq, 这样可以避免多个 CPU 访问同一个 rq 时产生的并发问题，提升调度器效率。</strong></p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/sched.h */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> &#123;</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_running;

    u64 nr_switches;

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * runqueue 采用的模块化的实现方式，各个不同的 Scheduling Class 都有自己的</span>
<span class="hljs-comment">     runqueue 实现。不同的 runqueue 的数据结构保存在如下属性之中</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span> <span class="hljs-title">cfs</span>;</span> <span class="hljs-comment">/* CFS runqueue 的实现 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_rq</span> <span class="hljs-title">rt</span>;</span>   <span class="hljs-comment">/* RT runqueue 的实现 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_rq</span> <span class="hljs-title">dl</span>;</span>   <span class="hljs-comment">/* Deadline runqueue 的实现 */</span>

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">curr</span>;</span> <span class="hljs-comment">/* 当前 runqueue 中正在运行的进程 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">idle</span>;</span>       <span class="hljs-comment">/* Idle 调度类的任务 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">stop</span>;</span>       <span class="hljs-comment">/* Stop 调度类的任务 */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">prev_mm</span>;</span>

    <span class="hljs-type">atomic_t</span> nr_iowait;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">root_domain</span> *<span class="hljs-title">rd</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_domain</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">sd</span>;</span>

    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cpu_capacity;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cpu_capacity_orig;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SMP */</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SCHEDSTATS</span>
    <span class="hljs-comment">/* latency stats */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span> <span class="hljs-title">rq_sched_info</span>;</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> rq_cpu_time;
    <span class="hljs-comment">/* could above be rq-&gt;cfs_rq.exec_clock + rq-&gt;rt_rq.rt_runtime ? */</span>

    <span class="hljs-comment">/* sys_sched_yield() stats */</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> yld_count;

    <span class="hljs-comment">/* schedule() stats */</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_count;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sched_goidle;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
&#125;;</code></pre></div>

<p>此处删除了该结构体的大多数字段，仅仅保留了一些主要的字段一探究竟，这些字段涉及如下几个方面：</p>
<ol>
<li><p>具体调度类的运行队列。不同的调度类选择下一个任务的逻辑是不同的，因此不同的调度类会有不同的调度队列实现方式，例如字段 <code>struct cfs_rq cfs</code> 就是 CFS 的调度队列</p>
</li>
<li><p>当前正在运行的进程，以及 stop 与 idle 这种特殊任务</p>
</li>
<li><p>如果是 SMP 架构，则 rq 中还会包含调度域的字段，调度器使用调度域中的信息来做负载均衡</p>
</li>
<li><p>一些统计信息</p>
</li>
</ol>
<h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><blockquote>
<p>每一个调度类都实现了<code>pick_next_task</code>，用于选择下一个调度的进程。而该函数选择的依据，跟进程的优先级密不可分。</p>
</blockquote>
<p>在Linux下，用户能通过系统调用设置优先级，分别是<code>nice</code>与<code>sched_setscheduler</code>，其中<code>nice</code>仅仅设置优先级，而<code>sched_setscheduler</code>还能改普通进程为实时进程。</p>
<p>站在用户的角度，用户只能接触到一类优先级，取值为[-20, 19]。</p>
<p>而站在内核的角度，能看到三种优先级，都在<code>task_struct</code>中。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: include/linux/sched.h */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span>
    <span class="hljs-type">int</span> prio; <span class="hljs-comment">//动态优先级</span>
    <span class="hljs-type">int</span> static_prio; <span class="hljs-comment">//静态优先级</span>
    <span class="hljs-type">int</span> normal_prio; <span class="hljs-comment">//将三种优先级归一化，否则无法比较优先级。</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rt_priority; <span class="hljs-comment">// 实时优先级</span>
	....
&#125;</code></pre></div>

<ul>
<li><p><code>static_prio</code>: 静态优先级。当<strong>用户通过 <code>nice</code> 与 <code>sched_setscheduler</code> 两个系统调用修改优先级时，改变的就是该字段</strong>。前文提到 nice 值的范围是[-20, 19], 而实时优先级的有效范围是[1, 99], 二者的重叠部分如何处理呢？内核在处理 nice 时会加上120, 完成 nice 值与静态优先级之间的转换。新进程创建时该值从父进程继承，静态优先级在进程执行过程中是不会改变的，而当其值发生改变的时候，其他相关优先级也需要重新计算（例如动态优先级）。</p>
</li>
<li><p><code>rt_priority</code>：实时优先级。可通过系统调用<code>chrt</code>修改，有效范围是 [1, 99], 数字越大优先级越高，<strong>用于实时调度</strong>，所以当数值是0时表示该进程是普通进程。</p>
</li>
<li><p><code>prio</code>: 动态优先级。为了调优IO密集和计算密集进程，动态优先级是在静态优先级动态调整而来，可调整的范围是+-5，可通过函数 <code>effective_prio()</code> 得到，具体实现如下。在$O(1)$调度器使用，CFS替代了$O(1)$调度器，在CFS中并为使用。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">effective_prio</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *p)</span> &#123;
    p-&gt;normal_prio = normal_prio(p);
    <span class="hljs-comment">/* 判断是否为实时优先级：如果 p.prio 的值小于 100(MAX_RT_PRIO的值), 则返回 1, 否则返回 0*/</span>
    <span class="hljs-keyword">if</span> (!rt_prio(p-&gt;prio))
        <span class="hljs-keyword">return</span> p-&gt;normal_prio;
    <span class="hljs-keyword">return</span> p-&gt;prio;
&#125;</code></pre></div>
</li>
<li><p><code>normal_prio</code>: 归一化优先级。 我们使用了不同的方式来刻画同一个概念，那么势必会带来管理上的麻烦，所谓归一化，就是设计一种转换方式，将这些不同的方法统一到同一种方法上去，从而简化问题的模型。内核设计了一种归一化算法，将所有的优先级统一到 [-1, 139] 这个区间上，并且数字越小优先级越大，该优先级就叫做归一化优先级。转换算法如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> __normal_prio(<span class="hljs-keyword">struct</span> task_struct *p) &#123;
    <span class="hljs-keyword">return</span> p-&gt;static_prio;
&#125;

<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">normal_prio</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *p)</span> &#123;
    <span class="hljs-type">int</span> prio;

    <span class="hljs-keyword">if</span> (task_has_dl_policy(p))
        <span class="hljs-comment">/* MAX_DL_PRIO为0, 因此Deadline的优先级永远为-1 */</span>
        prio = MAX_DL_PRIO - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task_has_rt_policy(p))
        <span class="hljs-comment">/* MAX_RT_PRIO为100, 而rt_priority的范围是[1,99]且数字越大对应的优先级越高，下面的算法实现了优先级反转，高优先级将对应小的数字。</span>
<span class="hljs-comment">         */</span>
        prio = MAX_RT_PRIO - <span class="hljs-number">1</span> - p-&gt;rt_priority;
    <span class="hljs-keyword">else</span>
        <span class="hljs-comment">/* 对于普通进程，直接返回静态优先级static_prio */</span>
        prio = __normal_prio(p);
    <span class="hljs-keyword">return</span> prio;
&#125;</code></pre></div></li>
</ul>
<h3 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h3><h4 id="为什么引入有CFS？"><a href="#为什么引入有CFS？" class="headerlink" title="为什么引入有CFS？"></a>为什么引入有CFS？</h4><p>传统的处理是将nice值映射到时间片，比如[ -20 … 0 … 19 ]的普通进程其缺省时间片为[800ms … 100ms … 5ms]。</p>
<p>传统基于优先级和时间片的算法有几点问题</p>
<ul>
<li>问题1：nice值映射到处理器绝对时间，进程切换无法最优化进行。</li>
<li>问题2：即使相对nice值相同，运行时间差距也可能很大。</li>
<li>问题3：由于是映射到时间片，所以时间片是定时器周期的整数倍。</li>
<li>问题4：为了交互进程，可能需要临时提高交互进程优先级，打破了公平规则。</li>
</ul>
<p><strong>分别举例说明一下</strong>1、2、3。</p>
<h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>问题1：nice值映射到处理器绝对时间，公平性难以把握。</p>
<p>假设现在存在两个活跃进程，nice值分别为0和19，时间片分别是100ms和5ms。即105ms一个周期，进行两次上下文切换。</p>
<p>但如果是两个nice值为19的进程，时间片就是5ms和5ms，10ms内进行两次上下文切换。</p>
<p>通常来说，我们希望后台进程优先级低，交互进程优先级高，后台能够获得更长的运行时间，交互进程能够尽快响应用户操作。</p>
<p>这样分配的话，会导致交互进程分配较长的时间片，交互进程大部分时间在阻塞，后台进程时间片短，后台进程也无法充分运行。</p>
<h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><p>问题2：即使相对nice值相同，运行时间差距也可能很大。</p>
<p>假设现在存在两个活跃进程，nice值分别为0和1，时间片分别是100ms和95ms。差距不大。</p>
<p>但对于nice值为18和19的进程，时间片为10ms和5ms。前者是后者两倍运行时间。</p>
<h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><p>由于nice值到时间片的绝对映射，所以时间片一定是定时器周期的整数倍。</p>
<p>假设定时器周期为1ms，则时间片差距至少为1ms。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><p>CFS，completely fair scheduler，即完全公平调度器。顾名思义，公平是CFS的核心。</p>
<p>理想情况下，公平就是CPU的时间均分给每一个进程，如果时间为T，共N个进程在运行，那么每一个进程的时间就是$\frac{T}{N}$。但现实是，系统无法知道T的具体值，而N也总是动态变化。前的调度逻辑都是基于时间片，绝对的公平几乎不可能实现。</p>
<p>CFS不再使用时间片，它的核心逻辑是以进程当前的实际运行时间为度量单位，记为runtime, 调度器每次调度时都选择runtime最小的进程。</p>
<h4 id="优先级与权重"><a href="#优先级与权重" class="headerlink" title="优先级与权重"></a>优先级与权重</h4><p>实际上，进程之间存在着优先级的差异，上面提到的runtime的完全公平是不符合实际需求的。所以引入优先级的概念，这个优先级就是我们常说的nice值。优先级越高，获得运行时间的比例也就应该越高，也就是这个进程的权重越高。</p>
<p>为了实现优先级的需求，但又保留公平性处理逻辑的简洁。CFS的做法是，调度仍然是选择运行时间最小的那个进程，不过这个时间是虚拟时间。在物理时间相同的情况下，进程的权重越高，它的虚拟时间流逝的就越快。</p>
<p>这样，调度就只需要选择虚拟时间vruntime最小的进程进行调度。进程运行时，将真实时间经过权重的放缩之后计算到虚拟时间。</p>
<h4 id="公平性、优先级与权重"><a href="#公平性、优先级与权重" class="headerlink" title="公平性、优先级与权重"></a>公平性、优先级与权重</h4><p>我们从公平角度来说，希望每一个进程都在CPU上运行相同的时间，但考虑到不同进程是有优先级的，比如说一个编辑器进程，我们希望他能够立刻响应，而一个跑深度学习的进程，我们倒是希望能够在后台运行，没有快速响应，慢几分钟几秒钟到是无所谓。这两种进程同时运行时，我们希望让编辑器进程优先响应，即编辑器进程优先级更高。</p>
<p>CFS的公平性本质上是对CPU时间的公平分配，而优先级的加入并没有改变这一点，优先级本质上是为了区分不同进程的重要性，只要调度器能够根据每个进程的重要性的比例来分配时间，那么它就依然是公平的。例如我们有三个进程 A, B, C, 其中B与C的重要性相等，而A的重要性是他们的两倍，那么在公平的分配策略下，三个进程得到的CPU时间比例应该是：</p>
<ul>
<li>A: 50%</li>
<li>B: 25%</li>
<li>C: 25%</li>
</ul>
<p>假设系统已经运行了100ms, 三个任务均分了该时间片：</p>
<ul>
<li>A: 33.3ms, 实际比例1&#x2F;3, 期望比例为1&#x2F;2, 差值为：1&#x2F;6</li>
<li>B: 33.3ms, 实际比例1&#x2F;3, 期望比例为1&#x2F;4, 差值为：1&#x2F;12</li>
<li>C: 33.3ms, 实际比例1&#x2F;3, 期望比例为1&#x2F;4, 差值为：1&#x2F;12</li>
</ul>
<p>此时A的比例差值最大，说明A所分配到的时间比例偏少，调度器应该选择A作为下一个任务来执行。整个过程略显复杂，需要每个任务都记录下自己的时间比例与权重比例，而CPU还需要计算出每一个进程的差值，选取插值最大的，有没有一种方式，让CPU看来，每一个进程运行的时间都相同，这样满足公平性且编码逻辑更加简洁，而进程运行的实际时间却具有权重之分？有， 那就是虚拟时间<code>vruntime</code>。</p>
<p>因此，逻辑就清晰了。<strong>CPU保证每个进程运行的逻辑时间相等，以保证公平性；将虚拟时间与物理时间按照权重进行一定的换算，以保证优先级的机制。</strong></p>
<h4 id="虚拟时间vruntime"><a href="#虚拟时间vruntime" class="headerlink" title="虚拟时间vruntime"></a>虚拟时间<code>vruntime</code></h4><h5 id="计算运行的虚拟时间"><a href="#计算运行的虚拟时间" class="headerlink" title="计算运行的虚拟时间"></a>计算运行的虚拟时间</h5><p>权重和优先级有一定映射关系，公式如下<br>$$<br>weight &#x3D; \frac{1024}{1.25^{nice}}<br>$$</p>
<p>nice是之前提到的用户能够设置的静态优先级，当nice&#x3D;0时，任务权重weight为1024，而1024作为权重的一个基准，内核中用宏<code>NICE_0_LOAD</code>表示，其他所有的权重都是在该基准上伸缩得来。</p>
<p>因此，计算虚拟时间vruntime就很简单了，公式如下<br>$$<br>vruntime &#x3D; \frac{wall_time * NICE_0_LOAD}{weight}<br>$$<br>其中<code>wall_time</code>代表物理时间（墙上时间，钟一般是挂在墙上的嘛）。</p>
<p>为了避免浮点运算，程序先进行放大后再缩小，代码为<code>vruntime = (wall_time * ((NICE_0_LOAD * 2^32) / weight)) &gt;&gt; 32</code>。而其中$\frac{2^{32}}{weight}$被称为<code>inv_weight</code>，由于频繁使用，因此以打表缓存的形式存在。<br>$$<br>inv_weight &#x3D; \frac{2^{32}}{weight}<br>$$</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> u32 sched_prio_to_wmult[<span class="hljs-number">40</span>] = &#123;
 <span class="hljs-comment">/* -20 */</span>     <span class="hljs-number">48388</span>,     <span class="hljs-number">59856</span>,     <span class="hljs-number">76040</span>,     <span class="hljs-number">92818</span>,    <span class="hljs-number">118348</span>,
 <span class="hljs-comment">/* -15 */</span>    <span class="hljs-number">147320</span>,    <span class="hljs-number">184698</span>,    <span class="hljs-number">229616</span>,    <span class="hljs-number">287308</span>,    <span class="hljs-number">360437</span>,
 <span class="hljs-comment">/* -10 */</span>    <span class="hljs-number">449829</span>,    <span class="hljs-number">563644</span>,    <span class="hljs-number">704093</span>,    <span class="hljs-number">875809</span>,   <span class="hljs-number">1099582</span>,
 <span class="hljs-comment">/*  -5 */</span>   <span class="hljs-number">1376151</span>,   <span class="hljs-number">1717300</span>,   <span class="hljs-number">2157191</span>,   <span class="hljs-number">2708050</span>,   <span class="hljs-number">3363326</span>,
 <span class="hljs-comment">/*   0 */</span>   <span class="hljs-number">4194304</span>,   <span class="hljs-number">5237765</span>,   <span class="hljs-number">6557202</span>,   <span class="hljs-number">8165337</span>,  <span class="hljs-number">10153587</span>,
 <span class="hljs-comment">/*   5 */</span>  <span class="hljs-number">12820798</span>,  <span class="hljs-number">15790321</span>,  <span class="hljs-number">19976592</span>,  <span class="hljs-number">24970740</span>,  <span class="hljs-number">31350126</span>,
 <span class="hljs-comment">/*  10 */</span>  <span class="hljs-number">39045157</span>,  <span class="hljs-number">49367440</span>,  <span class="hljs-number">61356676</span>,  <span class="hljs-number">76695844</span>,  <span class="hljs-number">95443717</span>,
 <span class="hljs-comment">/*  15 */</span> <span class="hljs-number">119304647</span>, <span class="hljs-number">148102320</span>, <span class="hljs-number">186737708</span>, <span class="hljs-number">238609294</span>, <span class="hljs-number">286331153</span>,
&#125;;</code></pre></div>

<p>具体实现的计算函数是<code>__calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load)</code>。delta即墙上时间，<code>&amp;se-&gt;load</code>即权重。</p>
<p>接下来我们再来看一下系统如何更新任务的vruntime以及其他的时间信息的，完成该任务的是函数 <code>update_curr()</code>:</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/fair.c */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">update_curr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq)</span> &#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> *<span class="hljs-title">curr</span> =</span> cfs_rq-&gt;curr;
    <span class="hljs-comment">/* 获取当前时间 */</span>
    u64 now = rq_clock_task(rq_of(cfs_rq));
    u64 delta_exec;

    <span class="hljs-keyword">if</span> (unlikely(!curr))
    <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* 本次更新vruntime与上次更新vruntime之间的时间差，即任务本次的运行时间，该值为墙上时间</span>
<span class="hljs-comment">    */</span>
    delta_exec = now - curr-&gt;exec_start;
    <span class="hljs-keyword">if</span> (unlikely((s64)delta_exec &lt;= <span class="hljs-number">0</span>))
    <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* 记录这次更新的时间 */</span>
    curr-&gt;exec_start = now;

    <span class="hljs-comment">/* 更新总的运行时间 */</span>
    curr-&gt;sum_exec_runtime += delta_exec;

    <span class="hljs-comment">/* 更新vruntime, 通过函数calc_delta_fair计算出墙上时间delta_exec对应的虚拟时间</span>
<span class="hljs-comment">    */</span>
    curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);
    <span class="hljs-comment">/* 更新队列的 min_vruntime */</span>
    update_min_vruntime(cfs_rq);

    <span class="hljs-comment">/* 下面的逻辑可以暂时不管 */</span>
    <span class="hljs-keyword">if</span> (entity_is_task(curr)) &#123;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">curtask</span> =</span> task_of(curr);

        trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);
        cgroup_account_cputime(curtask, delta_exec);
        account_group_exec_runtime(curtask, delta_exec);
    &#125;

    account_cfs_rq_runtime(cfs_rq, delta_exec);
&#125;</code></pre></div>

<p>任务的<code>vruntime</code>就靠函数 <code>update_curr</code> 来维护，系统在很多情况下都会调用该方法，包括任务在入队、出队时，调度中断函数也会周期性地调用该方法，以确保任务的各种时间信息随时都是最新的状态。</p>
<h5 id="调整睡眠的进程和新进程的vruntime"><a href="#调整睡眠的进程和新进程的vruntime" class="headerlink" title="调整睡眠的进程和新进程的vruntime"></a>调整睡眠的进程和新进程的<code>vruntime</code></h5><p>除了为运行的任务计算<code>vruntime</code>之外，调度器还需要调整新创建的任务及久睡方醒的任务的<code>vruntime</code>, 否则他们的<code>vruntime</code>将远远落后于一直在执行的任务，从而导致长久的霸占CPU. 该任务通过函数 <code>place_entity</code> 完成</p>
<p>该函数总是为目标任务加上一定的vruntime, 因此事实上是一个“惩罚函数”。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/fair.c */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">place_entity</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq, <span class="hljs-keyword">struct</span> sched_entity *se,</span>
<span class="hljs-params">                    <span class="hljs-type">int</span> initial)</span> &#123;
    <span class="hljs-comment">/* 以队列的min_vruntime为基础进行调整 */</span>
    u64 vruntime = cfs_rq-&gt;min_vruntime;

    <span class="hljs-comment">/* 对新创建的进程（initial=1）适当的惩罚，为其加上一定的 vruntime,</span>
<span class="hljs-comment">    * 函数sched_vslice将任务在一个调度周期内应当分配到的墙上时间换算成虚拟时间，调度周期会在下一节介绍</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-keyword">if</span> (initial &amp;&amp; sched_feat(START_DEBIT))
    	vruntime += sched_vslice(cfs_rq, se);

    <span class="hljs-keyword">if</span> (!initial) &#123;
    <span class="hljs-comment">/* 如果进程睡眠了很久，那么其 vruntime 可能远远小于队列中其他任务的vruntime,</span>
<span class="hljs-comment">        * 我们也需要对其vruntime</span>
<span class="hljs-comment">        * 进行惩罚，但进程被唤醒（initial=0）说明它所等待的事件已经得到了满足，需要马上干活，所以这里减去一定的vruntime作为补偿。*/</span>
    	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> thresh = sysctl_sched_latency;

        <span class="hljs-keyword">if</span> (sched_feat(GENTLE_FAIR_SLEEPERS))
            thresh &gt;&gt;= <span class="hljs-number">1</span>;

        vruntime -= thresh;
    &#125;

    <span class="hljs-comment">/* 确保不要因为 vruntime -=thresh 导致 se.vruntime 的值越来越小了 */</span>
    se-&gt;vruntime = max_vruntime(se-&gt;vruntime, vruntime);
&#125;</code></pre></div>





<h5 id="如何选择下一个进程"><a href="#如何选择下一个进程" class="headerlink" title="如何选择下一个进程"></a>如何选择下一个进程</h5><p>通过前文对于公平性的讨论，我们知道对于CFS所管理的任务而言，<code>vruntime</code>相等就是公平的，CFS的工作职责就是维持所有任务的<code>vruntime</code>尽可能相等。总结起来，CFS的工作原理如下：CFS为每个任务维护一个虚拟时间<code>vruntime</code>, 每次调度时都从<code>runqueue</code>中挑选<code>vruntime</code>最小的任务来执行，并将任务执行时所耗费的墙上时间根据任务的权重换算成虚拟时间累计起来；随着时间的消耗，当当前任务的<code>vruntime</code>数值不再是<code>runqueue</code>中最小的时，调度器将其放回<code>runqueue</code>, 重新选择下一个任务。</p>
<h4 id="调度周期"><a href="#调度周期" class="headerlink" title="调度周期"></a>调度周期</h4><p>从CFS的调度原理来考虑的话，CFS似乎不需要调度周期的概念，因为CFS并不是预先给任务分配时间片，而是根据大家当前的运行时间来判断谁应该是下一个该执行的任务，这样所有任务都随着时间的推进齐头并进。但为了用来调度延迟，CFS也需要引入调度周期。</p>
<p>什么是调度延迟呢？CFS不仅需要保证时间分配的公平，还要保证各个任务每隔一段时间就能够执行一次，一个任务在两次被调度到的时间间隔就是调度延迟。相反，调度器还需要保证任务在每次得到机会执行时，除了任务主动放弃CPU, 尽量不要太快地被踢出来，因为太频繁的上下文切换会导致系统的总体性能降低。所以 CFS 没有使用固定的时间长度作为调度周期，而是根据当前队列中的任务数量<strong>动态计算出调度周期</strong>的长度，该逻辑由函数 <code>__sched_period</code> 实现</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/fair.c */</span>
<span class="hljs-comment">/* 参数 nr_running 表示当前 cfs_rq 中的任务总数 */</span>
<span class="hljs-type">static</span> u64 __sched_period(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_running) &#123;
    <span class="hljs-comment">/* sched_nr_latency: 8 */</span>
    <span class="hljs-keyword">if</span> (unlikely(nr_running &gt; sched_nr_latency))
    	<span class="hljs-comment">/* sysctl_sched_min_granularity: 0.75ms */</span>
    	<span class="hljs-keyword">return</span> nr_running * sysctl_sched_min_granularity;
    <span class="hljs-keyword">else</span>
    	<span class="hljs-comment">/* sysctl_sched_latency: 6ms*/</span>
    	<span class="hljs-keyword">return</span> sysctl_sched_latency;
&#125;</code></pre></div>

<p><strong>当队列中所有的任务超过8个时，CFS的调度周期为任务总数乘以0.75ms，否则调度周期为固定的6ms, 这样可以保证任务的切换频率比较合理。</strong></p>
<p>算出调度周期之后，系统还需要为任务计算其在一个调度周期内的时间配额，函数 <code>sched_slice</code> 用来实现该逻辑：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/fair.c */</span>
<span class="hljs-type">static</span> u64 <span class="hljs-title function_">sched_slice</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq, <span class="hljs-keyword">struct</span> sched_entity *se)</span> &#123;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_running = cfs_rq-&gt;nr_running;
    u64 slice;

    <span class="hljs-comment">/* 调度周期 */</span>
    slice = __sched_period(nr_running + !se-&gt;on_rq);

    <span class="hljs-comment">/* 暂时不考虑组调度，此处的循环只会执行一次 */</span>
    for_each_sched_entity(se) &#123;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_weight</span> *<span class="hljs-title">load</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_weight</span> <span class="hljs-title">lw</span>;</span>

        cfs_rq = cfs_rq_of(se);
        <span class="hljs-comment">/* 整个运行队列 cfs_rq 的总权重 */</span>
        load = &amp;cfs_rq-&gt;load;

        <span class="hljs-comment">/* se-&gt;load.weight为se的权重，调用函数__calc_delta得到slice*se-&gt;load.weight/load.weight,</span>
<span class="hljs-comment">            * 即根据 se 在整个队列中的权重比例分配时间 */</span>
        slice = __calc_delta(slice, se-&gt;load.weight, load);
    &#125;

    <span class="hljs-keyword">if</span> (sched_feat(BASE_SLICE))
    	slice = max(slice, (u64)sysctl_sched_min_granularity);

    <span class="hljs-keyword">return</span> slice;
&#125;</code></pre></div>

<p>当任务在当前调度周期内的耗时超过自己的配额时，调度器就会将其踢出去，换其他任务来执行，这个值的检查的频率是由调度节拍决定的。调度节拍中将会详细讨论该逻辑。</p>
<h4 id="调度节拍"><a href="#调度节拍" class="headerlink" title="调度节拍"></a>调度节拍</h4><p>计算机系统随着时钟节拍需要周期性地做很多事情，例如刷新屏幕、数据落盘等，而进程调度是众多任务中最重要的之一。周期性调度也叫调度节拍，它的入口是函数 <code>scheduler_tick()</code>, 该函数最终会调用调度类的 <code>task_tick()</code> 方法完成操作：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/core.c */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">scheduler_tick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;
    <span class="hljs-type">int</span> cpu = smp_processor_id();
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span> =</span> cpu_rq(cpu);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">curr</span> =</span> rq-&gt;curr;

    <span class="hljs-comment">/* 调用当前任务的调度类的 task_tick 方法 */</span>
    curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="hljs-number">0</span>);

    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span>
    <span class="hljs-comment">/* SMP 架构下触发负载均衡 */</span>
    rq-&gt;idle_balance = idle_cpu(cpu);
    trigger_load_balance(rq);
    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
&#125;</code></pre></div>

<p>CFS 中实现 <code>task_tick</code> 方法的是函数 <code>task_tick_fair</code>:</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/fair.c */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task_tick_fair</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *curr, <span class="hljs-type">int</span> queued)</span> &#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span> *<span class="hljs-title">cfs_rq</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> *<span class="hljs-title">se</span> =</span> &amp;curr-&gt;se;

    <span class="hljs-comment">/* 在不考虑组调度的情况下，此处的循环只会迭代一次，处理的就是当前任务 */</span>
    for_each_sched_entity(se) &#123;
        cfs_rq = cfs_rq_of(se);
        entity_tick(cfs_rq, se, queued);
    &#125;
&#125;</code></pre></div>

<p>实际的逻辑都在函数 <code>entity_tick</code> 中，删除无关代码及与组调度相关的逻辑，主要逻辑如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/fair.c */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">entity_tick</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq, <span class="hljs-keyword">struct</span> sched_entity *curr, <span class="hljs-type">int</span> queued)</span> &#123;
    <span class="hljs-comment">/* 首先更新当前任务及队列的各种时间信息，详见 vruntime 一节 */</span>
    update_curr(cfs_rq);
    <span class="hljs-keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="hljs-number">1</span>)
        <span class="hljs-comment">/* 检查是否需要抢占当前任务 */</span>
    	check_preempt_tick(cfs_rq, curr);	
&#125;</code></pre></div>

<p>该函数的主要任务有两个，一个是更新任务的各种时间信息；另一个是检查当前任务是否已经执行地足够久了，如果是的话就需要对其进行抢占，换其它任务来执行。关于抢占的概念将在下一节中介绍。</p>
<h4 id="进程抢占"><a href="#进程抢占" class="headerlink" title="进程抢占"></a>进程抢占</h4><p>所谓抢占，就是停止当前正在执行的任务，换另一个任务来执行。导致这种情况发生的原因很多，例如当前任务已经运行了太长时间，需要让出CPU; 用户修改了任务优先级，导致当前任务应该被换下；或者优先级更高的任务被唤醒，需要立刻开始运行。但当这种情况发生时，<strong>调度器并不会真的立刻切换任务，而是调用 <code>resched_curr()</code> 函数为当前任务设置一个叫着 <code>TIF_NEED_RESCHED</code> 的标记位</strong>，该函数的主要逻辑如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/core.c */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">resched_curr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq)</span> &#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">curr</span> =</span> rq-&gt;curr;
    <span class="hljs-type">int</span> cpu;

    lockdep_assert_held(&amp;rq-&gt;lock);

    <span class="hljs-comment">/* 如果当前任务已经设置了 TIF_NEED_RESCHED 标记位，则返回 */</span>
    <span class="hljs-keyword">if</span> (test_tsk_need_resched(curr))
    <span class="hljs-keyword">return</span>;

    cpu = cpu_of(rq);

    <span class="hljs-keyword">if</span> (cpu == smp_processor_id()) &#123;
        <span class="hljs-comment">/* 设置标记位 */</span>
        set_tsk_need_resched(curr);
        set_preempt_need_resched();
        <span class="hljs-keyword">return</span>;
	&#125;
&#125;</code></pre></div>

<p><strong><code>TIF_NEED_RESCHED</code> 位被设置之后，调度器在下一次调度发生时就会进行真正的调度，将任务换下，进行上下文切换，运行新任务</strong>。具体的调度入口和调度时机在后文讨论。</p>
<p>调用<code>resched_curr()</code>的地方非常多，这里主要介绍两个典型场景：</p>
<ol>
<li>调度节拍中检测到任务运行时间耗尽</li>
<li>任务状态切换为可运行时，判断是否可以调用，例如创建新进程、任务苏醒。</li>
</ol>
<h5 id="运行时间耗尽"><a href="#运行时间耗尽" class="headerlink" title="运行时间耗尽"></a>运行时间耗尽</h5><p>前面提到每个调度周期内都有一定的时间配额，当任务耗尽了该时间片之后就需要让出CPU, 以便给其它任务提供运行的机会。在调度节拍一节中，提到 <code>entity_tick</code> 最后调用了<code>check_preempt_tick</code>，后者就是检查时间是否耗尽的函数，实现如下。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/fair.c */</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">check_preempt_tick</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq, <span class="hljs-keyword">struct</span> sched_entity *curr)</span> &#123;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ideal_runtime, delta_exec;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> *<span class="hljs-title">se</span>;</span>
    s64 delta;

    <span class="hljs-comment">/* 计算出当前任务在一个调度周期内的时间配额 */</span>
    ideal_runtime = sched_slice(cfs_rq, curr);
    <span class="hljs-comment">/* 计算出当前任务已经运行了多长时间 */</span>
    delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;
    <span class="hljs-keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;
        <span class="hljs-comment">/* 如果运行时长已经超过了任务自己的时间配额，则对任务进行抢占 */</span>
        resched_curr(rq_of(cfs_rq));
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-comment">/* 避免任务抢占发生得太过频繁 */</span>
    <span class="hljs-keyword">if</span> (delta_exec &lt; sysctl_sched_min_granularity)
    	<span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* 从cfs_fq中挑出vruntime最小的任务，即红黑树中最左子节点；并计算出当前任务与该任务的vruntime的差值</span>
<span class="hljs-comment">    */</span>
    se = __pick_first_entity(cfs_rq);
    delta = curr-&gt;vruntime - se-&gt;vruntime;

    <span class="hljs-comment">/* 如果当前任务的vruntime依然小于红黑树中所有任务的vruntime, 则不发生抢占 */</span>
    <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>)
    	<span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* 如果已经多除了相当部分，则可以抢占当前任务了 */</span>
    <span class="hljs-keyword">if</span> (delta &gt; ideal_runtime)
    	resched_curr(rq_of(cfs_rq));
&#125;</code></pre></div>

<p>可以看到最后一行，情况符合的话，就会调用<code>resched_curr</code>。</p>
<h5 id="创建新任务"><a href="#创建新任务" class="headerlink" title="创建新任务"></a>创建新任务</h5><p>新任务创建后可能需要立即运行，就可能会调用到<code>resched_curr</code>函数。创建完毕后，在<code>wake_up_new_task</code>检查是否需要调用<code>resched_curr</code>。</p>
<h4 id="调度入口"><a href="#调度入口" class="headerlink" title="调度入口"></a>调度入口</h4><p>调度入口就是真正执行调度的地方，由<code>schedule()</code>执行，保留核心代码，实现如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* file: kernel/sched/core.c */</span>
asmlinkage __visible <span class="hljs-type">void</span> __sched <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tsk</span> =</span> current;

    <span class="hljs-keyword">do</span> &#123;
        preempt_disable();
        <span class="hljs-comment">/* 调用函数 __schedule 来做具体的工作 */</span>
        __schedule(<span class="hljs-literal">false</span>);
        sched_preempt_enable_no_resched();
        <span class="hljs-comment">/* need_resched用来判断当前任务是否应该被抢占，此时的当前任务就是函数__schedule最新选择的任务，如果是的话那么继续调用函数__schedule以便调用下一个合适的任务。*/</span>
    &#125; <span class="hljs-keyword">while</span> (need_resched());
&#125;

<span class="hljs-type">static</span> <span class="hljs-type">void</span> __sched notrace __schedule(<span class="hljs-type">bool</span> preempt) &#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">prev</span>, *<span class="hljs-title">next</span>;</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *switch_count;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> prev_state;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq_flags</span> <span class="hljs-title">rf</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span>;</span>
    <span class="hljs-type">int</span> cpu;

    <span class="hljs-comment">/* 获取到当前CPU序号，进而获取到其runqueue */</span>
    cpu = smp_processor_id();
    rq = cpu_rq(cpu);
    <span class="hljs-comment">/* rq-&gt;curr 是当前正在执行的任务 */</span>
    prev = rq-&gt;curr;

    prev_state = prev-&gt;state;
    <span class="hljs-keyword">if</span> (!preempt &amp;&amp; prev_state) &#123;
        <span class="hljs-keyword">if</span> (signal_pending_state(prev_state, prev)) &#123;
            prev-&gt;state = TASK_RUNNING;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">/* preempt 如果为false,</span>
<span class="hljs-comment">                则说明此次调度不是由于任务抢占导致的，那么导致调度发生的原因就是任务主动要求让出CPU,</span>
<span class="hljs-comment">                对于由于IO事件进入睡眠的任务而言，需要先将其从运行队列中踢出去。该函数最终会调用调度类（sched_class）的</span>
<span class="hljs-comment">                dequeue_task 方法完成具体工作。*/</span>
            deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);
        &#125;
    &#125;

    <span class="hljs-comment">/* 从队列中选择下一个任务，该函数最终会调用调度类（sched_class的函数pick_next_task方法。对于CFS而言，就是选择vruntime最小的任务</span>
<span class="hljs-comment">    */</span>
    next = pick_next_task(rq, prev, &amp;rf);
    <span class="hljs-comment">/* 清除 prev 任务的TIF_NEED_RESCHED标记，因为此时它已经被抢占了 */</span>
    clear_tsk_need_resched(prev);

    <span class="hljs-keyword">if</span> (likely(prev != next)) &#123;
        <span class="hljs-comment">/* 完成上下文切换，CPU将开始执行刚刚挑出来的任务next了 */</span>
        rq = context_switch(rq, prev, next, &amp;rf);
    &#125;
&#125;</code></pre></div>

<p>其中<code>next = pick_next_task(rq, prev, &amp;rf);</code>就是前文提到的全局的<code>pick_next_task</code>，根据优先级遍历所有的调度类。</p>
<p>函数 <code>schedule()</code> 最后调用 <code>context_switch()</code> 完成上下文切换，至此，整个调度工作就完成了！</p>
<p>接下来讨论调度的时机，即什么时候调用<code>schedule()</code>。</p>
<h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><h5 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h5><p>在以下情况会检查<code>TIF_NEED_RESCHED</code>标志位，</p>
<ul>
<li>从系统调用返回用户空间时</li>
<li>从中断处理程序返回用户空间时</li>
</ul>
<p>检查到了则会调用<code>schedule</code>，进行任务调度。</p>
<h5 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h5><p>在以下情况可能发生内核抢占，检测到<code>TIF_NEED_RESCHED</code>标志位，或者显式调用</p>
<ul>
<li>中断处理程序正在执行，且返回内核空间之前</li>
<li>内核代码再一次具有可抢占性的时候</li>
<li>内核代码显示调用<code>schedule()</code></li>
<li>内核中的任务阻塞（同样导致调用<code>schedule</code>）</li>
</ul>
<p>前面提到，周期性调度会按照调度节拍检查当前任务是否超时，而该周期性调度程序是由中断实现的，返回时即会检查<code>TIF_NEED_RESCHED</code>标志位。</p>
<h4 id="重新调度"><a href="#重新调度" class="headerlink" title="重新调度"></a>重新调度</h4><p>所谓抢占，就是停止当前正在执行的任务，换另一个任务来执行。导致这种情况发生的原因很多，例如当前任务已经运行了太长时间，需要让出CPU; 用户修改了任务优先级，导致当前任务应该被换下；或者优先级更高的任务被唤醒，需要立刻开始运行。但当这种情况发生时，<strong>调度器并不会真的立刻切换任务，而是调用 <code>resched_curr()</code> 函数为当前任务设置一个叫着 <code>TIF_NEED_RESCHED</code> 的标记位</strong>，等下一个调度节拍来执行实际的调度。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>调度函数 <code>schedule()</code> 最后调用 <code>context_switch()</code> 完成上下文切换，<code>context_switch()</code>完成两项基本的工作</p>
<ul>
<li><strong>进程地址空间切换</strong>：声明在<code>&lt;sam/mmu_context.h&gt;</code>中的<code>switch_mm</code>：切换大部分虚拟内存。由于虚拟内存与MMU有关，具体的工作细节取决于处理器，主要包括<ul>
<li>加载页表：即修改页表基址寄存器成新的<code>task_struct-&gt;mm_struct-&gt;pgd</code>。</li>
<li>刷新TLB（有些体系会优化这个步骤，用到才刷新）</li>
<li>向MMU提供信息…</li>
</ul>
</li>
<li><strong>处理器状态切换：</strong>声明在<code>&lt;asm/system.h&gt;</code>中的<code>swtich_to</code>：保存、恢复内核栈信息（用户栈在上一步已经被切换）和PC、SP等寄存器信息，还有其他任何于体系结构相关的信息。</li>
</ul>
<p>由于与具体体系关系紧密，因此上下文切换代码通常使用汇编语言编写。</p>
<p>内核的<code>mm_struct</code>指向NULL。</p>
<h3 id="进程组、组调度"><a href="#进程组、组调度" class="headerlink" title="进程组、组调度"></a>进程组、组调度</h3><p>为什么要有进程组的概念呢？考虑如下情况，一个系统有100个进程，CFS会保证每个进程都获得1%的CPU时间，但实际上系统中的这100个进程可能隶属于两个用户A与B, 其中用户A拥有10个进程，用户B拥有90个进程，这种实现造成的结果是用户A只获得了10%的CPU时间，而用户B获得了90%的时间。如果用户B了解CFS的调度原理，那么他可以肆无忌惮地fork出更多的进程以攫取更多的CPU时间。可见CFS在进程层面上的公平，却导致了系统在用户层面上的不公平，甚至是漏洞。对于这种情况，一种更合理的策略是系统首先保证每个用户获得相同的时间，然后再对隶属于同一个用户的所有进程公平地分配该用户的时间。</p>
<p>将该概念进一步抽象，我们就得到了进程组的概念。<strong>进程组的引入实际上是增加了一个调度层级，调度器首先完成进程组的时间分配，再处理组内进程之间的时间分配，前文提到的用户分组只是进程组的一个特例</strong>。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>一个CPU有很多核心嘛，为了效率肯定需要做负载均衡的，每一个核心都需要做负载记账，当核心之间的负载不均衡时，需要进行任务迁徙，这个过程就是负载均衡。当然负载均衡需要考虑很多问题，比如这个CPU是什么架构是SMP还是NUMA，不同核心处理能力不同，迁移时vruntime又怎么处理等等。</p>
<h3 id="抽象层面"><a href="#抽象层面" class="headerlink" title="抽象层面"></a>抽象层面</h3><p>Linux为了更方便地扩展，抽象出了很多概念。举几个例子</p>
<p>调度类：每一个调度类都需要实现调度的通用函数，即对调度相关的函数声明进行实现。这其实就是一种面向对象的思想。</p>
<p>调度实体：进程就是一种调度实体，线程也是。在Linux下的进程和线程都是task_struct表示，区别只是是否共享虚拟地址空间。这其实是一种抽象，而Linux的task_struct就是一种可调度的实体）。</p>
<p>调度组：进程组的引入实际上是增加了一个调度层级，调度器首先完成进程组的时间分配，再处理组内进程之间的时间分配，前文提到的用户分组只是进程组的一个特例。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Linux内核设计与实现》第三版</li>
<li>《深入Linux内核架构》</li>
<li><a target="_blank" rel="noopener" href="https://s3.shizhz.me/">Linux核心概念详解</a></li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>调度域</li>
<li>调度实体</li>
<li>负载记账</li>
<li>负载均衡</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Process</div>
      <div>https://messenger1th.github.io/2023/12/18/Linux/Process/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Epoch</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/18/Linux/Physical%20Memory/" title="Physical Memory">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Physical Memory</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/18/Linux/Ext%20File%20System/" title="Ext File System">
                        <span class="hidden-mobile">Ext File System</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-left: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Linux"
        id="heading-edc9f0a5a5d57797bf68e37364743831" role="tab" data-toggle="collapse" href="#collapse-edc9f0a5a5d57797bf68e37364743831"
        aria-expanded="true"
      >
        Linux
        <span class="list-group-count">(6)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-edc9f0a5a5d57797bf68e37364743831"
           role="tabpanel" aria-labelledby="heading-edc9f0a5a5d57797bf68e37364743831">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/12/18/Linux/Ext%20File%20System/" title="Ext File System"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Ext File System</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Physical%20Memory/" title="Physical Memory"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Physical Memory</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Process/" title="Process"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">Process</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Slub/" title="Slub"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Slub</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/Virtual%20Memory/" title="Virtual Memory"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Virtual Memory</span>
        </a>
      
    
      
      
        <a href="/2023/12/18/Linux/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络编程</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
